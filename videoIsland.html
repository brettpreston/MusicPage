<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Three.js Enhanced Island Scene</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; }
        #container { position: relative; width: 100vw; height: 100vh; }
        #info {
            position: absolute;
            top: 10px;
            width: 100%;
            text-align: center;
            color: white;
            z-index: 100; /* Ensure info is above renderers */
            font-family: Arial, sans-serif;
            background-color: rgba(0,0,0,0.6);
            padding: 5px;
            pointer-events: none; /* Allow clicks through to canvas */
        }
        #instructions {
             pointer-events: auto; /* Allow clicking the lock instruction */
             cursor: pointer;
             text-decoration: underline;
        }
        /* Style for both renderers to overlap */
        canvas, .css3d-renderer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }
        /* Prevent CSS3D renderer background from blocking pointer events */
        .css3d-renderer {
            pointer-events: none;
        }
        /* Allow pointer events ONLY on the iframe itself */
        .css3d-renderer iframe {
            pointer-events: auto;
        }
    </style>
</head>
<body>
    <div id="info">
        <span id="instructions">Click here to lock controls</span> (WASD: Move, Mouse: Look)
        <br>
        Press ESC to unlock cursor and interact with video player.
    </div>
    <div id="container">
        </div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.163.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.163.0/examples/jsm/"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { PointerLockControls } from 'three/addons/controls/PointerLockControls.js';
        import { CSS3DRenderer, CSS3DObject } from 'three/addons/renderers/CSS3DRenderer.js';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
        import { SSAOPass } from 'three/addons/postprocessing/SSAOPass.js';

        let scene, camera, webglRenderer, cssRenderer, controls;
        let cssScene;
        let moon, moonLight;
        let moveForward = false;
        let moveBackward = false;
        let moveLeft = false;
        let moveRight = false;
        const velocity = new THREE.Vector3();
        const direction = new THREE.Vector3();
        const clock = new THREE.Clock();
        let isRunning = false; // Track if the player is running
        let isJumping = false; // Track if the player is jumping
        let jumpVelocity = 0; // Velocity for jumping
        const jumpHeight = 5; // Height of the jump
        let composer;

        const YOUTUBE_VIDEO_ID = 'rwsPKpSoYa4'; // <<<--- YOUR YOUTUBE VIDEO ID
        const ISLAND_SIZE = 250; // Make island bigger
        const ISLAND_SEGMENTS = 100; // More segments for smoother terrain/colors
        const TERRAIN_MAX_HEIGHT = 4; // Max height of terrain above water level
        const TERRAIN_FREQ_X = 0.1;
        const TERRAIN_FREQ_Z = 0.08;
        const WATER_LEVEL = 0.5; // Y position offset for the island mesh

        // Colors for terrain gradient
        const sandColor = new THREE.Color(0xf4a460); // Sandy yellow/brown
        const grassColor = new THREE.Color(0x228b22); // Forest green
        const gradientStartHeight = 0.1; // Height above water level where sand ends
        const gradientEndHeight = 2.0;   // Height above water level where full green starts

        // Add fog for underwater effect
        const underwaterFogColor = new THREE.Color(0x001e3f); // Deep blue color
        const underwaterFogDensity = 0.15; // Increased density for thicker fog
        const defaultFog = scene ? scene.fog : null; // Save the default fog (if any)

        // Function to update fog based on camera position
        function updateFog() {
            if (camera.position.y < WATER_LEVEL - 0.55) { // Switch fog just below the water surface
                // Add thick blue fog underwater
                scene.fog = new THREE.FogExp2(underwaterFogColor, underwaterFogDensity);
            } else {
                // Remove fog or restore default fog above water
                scene.fog = defaultFog;
            }
        }

        init();
        animate();

        // Helper function to calculate terrain height at specific world coordinates
        function getTerrainHeight(x, z) {
            // Use the same sine wave calculation as in island geometry creation
            const distanceFromCenter = Math.sqrt(x * x + z * z); // Calculate distance from center
            const taperingFactor = Math.max(0, (ISLAND_SIZE / 2 - distanceFromCenter) / (ISLAND_SIZE / 2)); // Tapering effect
            const height = (TERRAIN_MAX_HEIGHT * taperingFactor * 
                           Math.sin(x * TERRAIN_FREQ_X) *
                           Math.cos(z * TERRAIN_FREQ_Z)) - (1 - taperingFactor) * 2.5; // Allow height to go deeper below water level
            return height + WATER_LEVEL; // Add base water level offset
        }

        function init() {
            // --- Basic Setup ---
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x080818); // Slightly brighter night sky

            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 5, 25); // Start position adjusted slightly

            // --- WebGL Renderer ---
            webglRenderer = new THREE.WebGLRenderer({ antialias: true });
            webglRenderer.setSize(window.innerWidth, window.innerHeight);
            webglRenderer.setPixelRatio(window.devicePixelRatio);
            webglRenderer.shadowMap.enabled = true;
            webglRenderer.shadowMap.type = THREE.BasicShadowMap; // Hard shadows
            document.getElementById('container').appendChild(webglRenderer.domElement);

            // --- CSS3D Renderer ---
            cssRenderer = new CSS3DRenderer();
            cssRenderer.setSize(window.innerWidth, window.innerHeight);
            cssRenderer.domElement.classList.add('css3d-renderer');
            document.getElementById('container').appendChild(cssRenderer.domElement);
            cssScene = new THREE.Scene();

            // --- Lighting ---
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.1); // Lower intensity for ambient light
            scene.add(ambientLight);

            // Replace directional light with a point light that has no attenuation
            const pointLight = new THREE.PointLight(0xffffff, 100, 0); // Increased intensity (2.5 * 4 = 10)
            pointLight.position.set(50, 50, 100); // Light position
            pointLight.castShadow = true; // Enable shadows

            // Configure shadow properties for the point light
            pointLight.shadow.mapSize.width = 1024; // Shadow map resolution
            pointLight.shadow.mapSize.height = 1024;
            pointLight.shadow.camera.near = 1; // Minimum distance for shadows
            pointLight.shadow.camera.far = 500; // Maximum distance for shadows
            pointLight.shadow.bias = -0.001; // Adjust shadow bias if needed

            scene.add(pointLight);

            moonLight = new THREE.PointLight(0xffffff, 2.5, 400, 1.0);
            moonLight.castShadow = true; // Ensure this is true

            moonLight.shadow.mapSize.width = 1024; // Keep shadow map size reasonable
            moonLight.shadow.mapSize.height = 1024;
            moonLight.shadow.camera.near = 5;    // Adjust shadow camera frustum
            moonLight.shadow.camera.far = 350;
            moonLight.shadow.bias = -0.001; // Adjust shadow bias if needed
            moonLight.intensity = 100; // Increase intensity
            scene.add(moonLight);

            // --- Moon Object ---
            const moonGeometry = new THREE.SphereGeometry(6, 32, 32); // Slightly larger moon
            const moonMaterial = new THREE.MeshBasicMaterial({ color: 0xf5f3ce, transparent: false, opacity: 0.8 });
            moon = new THREE.Mesh(moonGeometry, moonMaterial);

            // Move the moon to the same position as the directional light
            moon.position.set(50, 50, 105);      // Moon position slightly forward
            moonLight.position.copy(moon.position); // Ensure the moonlight follows the moon
            moon.castShadow = false; // Disable shadow casting for the moon
            scene.add(moon);

            // --- Stars ---
            // (Star generation code remains the same as before)
             const starVertices = [];
            for (let i = 0; i < 10000; i++) {
                const x = THREE.MathUtils.randFloatSpread(2500); // Spread stars further
                const y = THREE.MathUtils.randFloatSpread(2500);
                const z = THREE.MathUtils.randFloatSpread(2500);
                const d = Math.sqrt(x*x + y*y + z*z);
                 if (d > 400 && y > -150) {
                    starVertices.push(x, y, z);
                }
            }
            const starGeometry = new THREE.BufferGeometry();
            starGeometry.setAttribute('position', new THREE.Float32BufferAttribute(starVertices, 3));
            const starMaterial = new THREE.PointsMaterial({ color: 0xffffff, size: 0.6, sizeAttenuation: true });
            const stars = new THREE.Points(starGeometry, starMaterial);
            scene.add(stars);


            // --- Island with Sine Wave Height and Vertex Colors ---
            const islandGeometry = new THREE.PlaneGeometry(ISLAND_SIZE, ISLAND_SIZE, ISLAND_SEGMENTS, ISLAND_SEGMENTS);
            const positions = islandGeometry.attributes.position;
            const colors = new THREE.Float32BufferAttribute(positions.count * 3, 3); // x3 for R, G, B

            for (let i = 0; i < positions.count; i++) {
                const x = positions.getX(i);
                const z = positions.getY(i); // Corresponds to Z-axis in world space after rotation

                // Calculate height using the same method as getTerrainHeight
                const distanceFromCenter = Math.sqrt(x * x + z * z); // Calculate distance from center
                const taperingFactor = Math.max(0, (ISLAND_SIZE / 2 - distanceFromCenter) / (ISLAND_SIZE / 2)); // Tapering effect
                const height = (TERRAIN_MAX_HEIGHT * taperingFactor * 
                               Math.sin(x * TERRAIN_FREQ_X + Math.random() * 0.2) *
                               Math.cos(z * TERRAIN_FREQ_Z + Math.random() * 0.2)) - (1 - taperingFactor) * 2.5; // Allow height to go deeper below water level

                positions.setZ(i, height); // Set height (becomes Y in world space)

                // Calculate color based on height (relative to base water level)
                const currentHeightAboveWater = height; // Height relative to plane's origin
                let colorFactor = 0;

                if (currentHeightAboveWater <= gradientStartHeight) {
                    colorFactor = 0; // Pure sand
                } else if (currentHeightAboveWater >= gradientEndHeight) {
                    colorFactor = 1; // Pure grass
                } else {
                    // Calculate interpolation factor between sand and grass levels
                    colorFactor = (currentHeightAboveWater - gradientStartHeight) / (gradientEndHeight - gradientStartHeight);
                }
                colorFactor = THREE.MathUtils.clamp(colorFactor, 0, 1); // Ensure factor is between 0 and 1

                // Interpolate color
                const finalColor = new THREE.Color().lerpColors(sandColor, grassColor, colorFactor);
                colors.setXYZ(i, finalColor.r, finalColor.g, finalColor.b);
            }

            islandGeometry.setAttribute('color', colors);
            islandGeometry.computeVertexNormals(); // IMPORTANT for lighting after modifying vertices
            islandGeometry.rotateX(-Math.PI / 2); // Rotate to be horizontal

            const islandMaterial = new THREE.MeshStandardMaterial({
                roughness: 0.9, // Higher roughness for less shine
                metalness: 0.0, // No metallic effect
                side: THREE.DoubleSide,
                vertexColors: true, // Use vertex colors for terrain gradient
                emissive: 0x000000 // Ensure no self-emission
            });
            const island = new THREE.Mesh(islandGeometry, islandMaterial);
            island.position.y = WATER_LEVEL; // Set base height
            island.receiveShadow = true; // Island receives shadows
            scene.add(island);


            // --- Ocean ---
            const oceanGeometry = new THREE.CircleGeometry(600 / 2, ISLAND_SEGMENTS); // Changed to CircleGeometry
            oceanGeometry.rotateX(- Math.PI / 2);
            const oceanMaterial = new THREE.MeshStandardMaterial({
                color: 0x002040, // Slightly adjusted ocean color
                metalness: 0.2,
                roughness: 0.4,
                transparent: true,
                opacity: 0.92,
                side: THREE.DoubleSide // Make water visible from below
            });
            const ocean = new THREE.Mesh(oceanGeometry, oceanMaterial);
            ocean.position.y = -0.1;
            ocean.receiveShadow = true; // Allow island shadows on water
            scene.add(ocean);

            // --- Trees ---
            const treeMaterial = new THREE.MeshStandardMaterial({
                color: 0x2E8B57, // SeaGreen
                roughness: 0.8
            });
            const treeGeometry = new THREE.ConeGeometry(0.8, 4, 8); // Base Radius, Height, Segments
            treeGeometry.translate(0, 2, 0); // Move origin to base of cone

            for (let i = 0; i < 30; i++) { // Add 30 trees
                const tree = createTree(treeGeometry, treeMaterial);
                if (tree) {
                    tree.castShadow = true; // Trees cast shadows
                    scene.add(tree);
                }
            }

            // --- Rocks ---
             const rockMaterial = new THREE.MeshStandardMaterial({
                color: 0x696969, // DimGray
                roughness: 0.7,
                metalness: 0.1
            });
            const rockGeometry = new THREE.IcosahedronGeometry(0.6, 0); // Radius, Detail level (0 = basic)

            for (let i = 0; i < 25; i++) { // Add 25 rocks
                const rock = createRock(rockGeometry, rockMaterial);
                if (rock) {
                    rock.castShadow = true; // Rocks cast shadows
                    rock.receiveShadow = true; // Rocks receive shadows
                    scene.add(rock);
                }
            }


            // --- Floating YouTube Screen (using CSS3DRenderer) ---
            const videoWidth = 4.8 * 6; // Width in 3D units
            const videoHeight = 2.7 * 6; // Height in 3D units (16:9 aspect ratio)

            const iframe = document.createElement('iframe');
            iframe.style.width = '1920px';
            iframe.style.height = '1080px';
            iframe.style.border = '10px';
            iframe.style.backgroundColor = 'black'; // Background while loading
            iframe.src = `https://www.youtube.com/embed/${YOUTUBE_VIDEO_ID}?autoplay=1&loop=1&playlist=${YOUTUBE_VIDEO_ID}&enablejsapi=1&origin=${window.location.origin}`; // Added enablejsapi and origin for potential future API use
            iframe.setAttribute('allowfullscreen', '');
            iframe.setAttribute('allow', 'autoplay; encrypted-media; picture-in-picture'); // Added picture-in-picture possibility
            iframe.style.pointerEvents = 'auto'; // Ensure iframe allows pointer events

            const cssObject = new CSS3DObject(iframe);
            const scaleFactor = videoWidth / parseInt(iframe.style.width);
            cssObject.scale.set(scaleFactor, scaleFactor, scaleFactor);
            cssObject.position.set(15, 10, -20); // Adjusted position
            cssObject.rotation.y = 0;
            cssScene.add(cssObject);

            // --- Create a Plane for Depth Testing ---
            const planeGeometry = new THREE.PlaneGeometry(videoWidth, videoHeight);
            const planeMaterial = new THREE.MeshBasicMaterial({
                color: 0xffffff,
                transparent: true,
                opacity: 0.0, // Make it invisible but still participate in depth testing
                depthWrite: true // Ensure it writes to the depth buffer
            });
            const depthPlane = new THREE.Mesh(planeGeometry, planeMaterial);
            depthPlane.position.copy(cssObject.position); // Match the position of the iframe
            depthPlane.rotation.copy(cssObject.rotation); // Match the rotation of the iframe
            cssScene.add(depthPlane);

            // --- Controls ---
            controls = new PointerLockControls(camera, document.body);

            const blocker = document.getElementById('info');
            const instructions = document.getElementById('instructions');
            const cssRendererElement = cssRenderer.domElement;

            instructions.addEventListener('click', function () {
                controls.lock();
            });

            controls.addEventListener('lock', function () {
                blocker.style.display = 'none';
                cssRendererElement.style.pointerEvents = 'auto'; // Enable interaction with iframe
            });

            controls.addEventListener('unlock', function () {
                blocker.style.display = 'block';
                cssRendererElement.style.pointerEvents = 'auto'; // Enable interaction with iframe
            });

            scene.add(controls.getObject());

            const onKeyDown = function (event) {
                switch (event.code) {
                    case 'KeyW': moveForward = true; break;
                    case 'KeyA': moveLeft = true; break;
                    case 'KeyS': moveBackward = true; break;
                    case 'KeyD': moveRight = true; break;
                    case 'ShiftLeft': isRunning = true; break; // Start running
                    case 'Space': if (!isJumping) { isJumping = true; jumpVelocity = jumpHeight; } break; // Start jump
                }
            };

            const onKeyUp = function (event) {
                switch (event.code) {
                    case 'KeyW': moveForward = false; break;
                    case 'KeyA': moveLeft = false; break;
                    case 'KeyS': moveBackward = false; break;
                    case 'KeyD': moveRight = false; break;
                    case 'ShiftLeft': isRunning = false; break; // Stop running
                }
            };

            document.addEventListener('keydown', onKeyDown);
            document.addEventListener('keyup', onKeyUp);

            window.addEventListener('resize', onWindowResize);

            // --- Post-Processing Setup ---
            const renderPass = new RenderPass(scene, camera);
            const bloomPass = new UnrealBloomPass(
                new THREE.Vector2(window.innerWidth, window.innerHeight),
                2.0, // Strength of the bloom
                0.5, // Radius
                0.75 // Threshold
            );

            // --- SSAO Pass ---
            const ssaoPass = new SSAOPass(scene, camera, window.innerWidth, window.innerHeight);
            ssaoPass.kernelRadius = 16; // Radius of the ambient occlusion effect
            ssaoPass.minDistance = 0.005; // Minimum occlusion distance
            ssaoPass.maxDistance = 0.1; // Maximum occlusion distance

            composer = new EffectComposer(webglRenderer);
            composer.addPass(renderPass);
            composer.addPass(ssaoPass); // Add SSAO pass before bloom
            composer.addPass(bloomPass);

            // Resize composer on window resize
            window.addEventListener('resize', () => {
                composer.setSize(window.innerWidth, window.innerHeight);
                ssaoPass.setSize(window.innerWidth, window.innerHeight); // Update SSAO size
            });
        }

        // --- Function to Create and Place a Tree ---
        function createTree(geometry, material) {
            const mesh = new THREE.Mesh(geometry, material);
            mesh.castShadow = true;

            // Place randomly on the island
            const margin = 5; // Don't place too close to the edge
            const randomX = THREE.MathUtils.randFloat(-ISLAND_SIZE / 2 + margin, ISLAND_SIZE / 2 - margin);
            const randomZ = THREE.MathUtils.randFloat(-ISLAND_SIZE / 2 + margin, ISLAND_SIZE / 2 - margin);

            const terrainY = getTerrainHeight(randomX, randomZ); // Get height at this point

            console.log(`Tree Position: X=${randomX}, Z=${randomZ}, Height=${terrainY}`); // Log height

            // Ensure the tree is not placed under water level
            if (terrainY > WATER_LEVEL) {
                mesh.position.set(randomX, terrainY, randomZ);
                mesh.rotation.y = Math.random() * Math.PI * 2; // Random rotation
                mesh.scale.setScalar(THREE.MathUtils.randFloat(0.8, 1.2)); // Slight size variation
                return mesh;
            }

            // Return null if the tree is below water level
            return null;
        }

        // --- Function to Create and Place a Rock ---
        function createRock(geometry, material) {
            const mesh = new THREE.Mesh(geometry, material);
            mesh.castShadow = true;
            mesh.receiveShadow = true; // Rocks can receive shadows too

             const margin = 2;
            const randomX = THREE.MathUtils.randFloat(-ISLAND_SIZE / 2 + margin, ISLAND_SIZE / 2 - margin);
            const randomZ = THREE.MathUtils.randFloat(-ISLAND_SIZE / 2 + margin, ISLAND_SIZE / 2 - margin);

            const terrainY = getTerrainHeight(randomX, randomZ);

            // Only place rocks below a certain height (e.g., not on high peaks)
            if (terrainY < WATER_LEVEL + gradientEndHeight * 0.8) {
                 mesh.position.set(randomX, terrainY + 0.1, randomZ); // +0.1 slightly embeds it
                 mesh.rotation.set(
                    Math.random() * Math.PI,
                    Math.random() * Math.PI,
                    Math.random() * Math.PI
                );
                mesh.scale.setScalar(THREE.MathUtils.randFloat(0.6, 1.5));
                 return mesh;
            } else {
                // If too high, return a dummy object or null (easier to just return the mesh, won't be added if null)
                // For simplicity, we'll just return the mesh - it might float if terrain is steep,
                // or we could skip adding it. Let's return it.
                mesh.position.set(randomX, terrainY + 0.1, randomZ);
                 return mesh;
            }
        }


        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            webglRenderer.setSize(window.innerWidth, window.innerHeight);
            cssRenderer.setSize(window.innerWidth, window.innerHeight);
        }

        function animate() {
            requestAnimationFrame(animate);

            const delta = Math.min(clock.getDelta(), 0.1); // Cap delta to prevent large jumps

            // Movement logic (same as before)
            if (controls.isLocked === true) {
                velocity.x -= velocity.x * 10.0 * delta;
                velocity.z -= velocity.z * 10.0 * delta;

                direction.z = Number(moveForward) - Number(moveBackward);
                direction.x = Number(moveRight) - Number(moveLeft);
                direction.normalize(); // Ensures consistent speed

                const speed = isRunning ? 160.0 : 80.0; // Double speed when running
                if (moveForward || moveBackward) velocity.z -= direction.z * speed * delta;
                if (moveLeft || moveRight) velocity.x -= direction.x * speed * delta;

                controls.moveRight(-velocity.x * delta);
                controls.moveForward(-velocity.z * delta);

                // Jumping logic
                if (isJumping) {
                    jumpVelocity -= 9.8 * delta; // Gravity effect
                    controls.getObject().position.y += jumpVelocity * delta; // Move up/down based on jump velocity
                    if (controls.getObject().position.y <= getTerrainHeight(controls.getObject().position.x, controls.getObject().position.z)) {
                        controls.getObject().position.y = getTerrainHeight(controls.getObject().position.x, controls.getObject().position.z); // Reset to ground level
                        isJumping = false; // Reset jumping state
                    }
                } else {
                    // Update camera position based on terrain height (simple collision)
                    const currentX = controls.getObject().position.x;
                    const currentZ = controls.getObject().position.z;
                    const terrainY = getTerrainHeight(currentX, currentZ);
                    const playerHeight = 1.8; // Eye level height above ground
                    controls.getObject().position.y = terrainY + playerHeight;
                }

                // Update fog based on camera position
                updateFog();
            }

            // Render the WebGL scene
            composer.render();

            // Render the CSS3D scene
            cssRenderer.render(cssScene, camera);
        }

    </script>
</body>
</html>